---
title: 自拟！JAVASE死知识！！！
category: 笔记
tag:
  - note
head:
  - - meta
    - name: keywords
      content: JVM,JDK,JRE,字节码详解,Java 基本数据类型,装箱和拆箱
  - - meta
    - name: description
      content: 全网质量最高的Java基础常见知识点和面试题总结，希望对你有帮助！
---
# JAVA基础

> 八股文，如果可以，真不想准备这些死知识，还是那些生动的项目开发让我感到兴奋。



## SE阶段[基础在脑中，不是写出来的]

**挑着写，随便写**

### **JAVA三大特性[其实是四个]**

1. 封装
2. 继承
3. 多态，重载编译器多态[因为编译的时候就可以指名用哪个啦]，重写运行时多态[机械要在运行的时候才知道应该用哪个]

其实还有一个抽象，不过三大特性都有抽象这个抽象的概念，笑:grinning:

### 修饰符[1+1=2]

只记一下，Protected不被其他包看到[那是肯定呀]。default子类不能用[这个确实有时候能忘]

### Clone的意义

克隆一个对象出来，就随意操作这个对象值了。

应用场景我想想，大概就是当一个对象是一个方法的入参的时候。

又用这个对象操作数据库[更新]，又要修改值，最后又要返回一个纯净的值。

这时候Clone的意义就出来了，不过其实应该还有更好的解决方法吧。

### &和&&

&&短路，前false后就不执行了。|同理。

### 跳出嵌套循环

给个标识，内层循环跳出循环时改变标识值为true。

外层循环判断true结束循环。

不过当前jdk8流操作可以更简便，使用return结束循环。

### hashCode和equals

重写equals一定要重写hashcode：

没什么好理解的，就是hashcode是本地方法，equals默认使用它的话就是简单的去判断内存地址。

但是如果重写了hashcode的话，应该就是去计算对象内属性值的hash总和了。

所以重写equals要有意义的话就一定要重写hashcode了

然后就是一个定义：两对象相同hashcode一定相同。hashcode相同不一定是一个对象。

### String

string不能继承，被final修饰

所以操作string的时候其实都是重新生成一个新的string。消耗内存

### 抽象属性

怎么搞都是问抽象类和接口的区别啊，特性啥的了。

抽象类可以有具体方法和抽象方法，成员都要是public，其余都是一个正常类看待了

接口方法不能是private，因为一定要被实现呀。不能有静态方法，同理前面。有继承接口的操作。常量都被static final修饰了，

### == equals

测试都知道的东西，前者比地址-》基本数据比值。 equals比内容，或者说对象内容的地址值

### 向上转型和向下转型

```
List list=new ArrayList();
```

这样是向上转型了，list只能使用List接口中有的方法，但实际使用的方法是ArrayList中的

```
List list=new ArrayList();
List list = （List）list;
```

如果上面代码可以运行[肯定不能啦]，则说明这个List变成了List，其方法却是ArrayList的，称之为向下转型。

### 异常

Exception，和Error。

error死机械，Exception死代码。

@Transactional 事务注解默认配置的是RunTimeException，运行异常。

然后这个异常一般都是开发者手动根据业务抛出去的，所以要注意配置默认异常。

throw手动抛出  throws方法头上抛出

### Math

说起这个工具类，当时刚学的时候还专门去记忆过。不过到实际开发中缺陷太明显了。

比如最常用的random获取随机数，Math的赋值太那个啥了。市场上有大把的开源工具能用，比如easy-randowm。

还有什么计算公式，在开发中其实不如把公式写出来的好。便于其他人阅读理解代码。

Math.round()这个取整，记住是向值大的一边，右边取整。

### Switch

switch除了基本知识，什么7之后能用String，不能用long外。

在上周影响里比较深的就是配合枚举使用的场景了

当switch中是枚举时，case里也是枚举类型的。不用想着从枚举转值。

### StringBuilder和StringBuffer

这个姑且提一嘴，Builder顺嘴所以是单线程，在jdk5中引入，Buffer读出来复数感，所以是多线程。

除此之外，联想记忆的话就是和String的关系了。

前面提到String被final修饰，所以String+String的运算，其实就是创建一个新的String。

当运算很多的时候就非常消耗性能。

所以StringB....系列，使用append方法操作时，比直接用+号是省略了其中创建Stringb和新建String过程。

实际上都一样，但是过程少一些。还有一点+号多的时候，创建new stringbuilder的语法在循环内。

### 日期工具

Data已经很少用了，在项目中玩玩使用的是LocalDatetime

但是Localdatetime在开发的时候也踩过几个坑

首先是一定要注意这个东西，在不设置时间或者格式的时候 返回出来中间是有一个H的。

然后就是配合@JsonFormat使用的时候，要注意在单项目中无所谓，但是要注意其实这东西会变成字符形式。所以在接口间传输，或微服务调用时，要用string接受。

然后就是Localdatetime的一些基本api了，其他的不提就想一下用的很多的。

时间的计算，Duration。

### 数据类型

byte short int long float double char boolean 

boolean一个字节中一位。

要想的点，重要的是应该要记住float - double - 整数类型转换的精准度问题。

还有就是一个表达式：

short i = i+1  这样的编译是会报错，但是 i+=i  这样的加一是不会报错，隐形的强制转换。

### 包装类型

因为昨天正好写了包装类型 反射判断的逻辑，所以还有影响。

就是包装类型是没有api特殊判断的，相当于承接基本数据的普通类，而且它127之后就是比地址，不精准了。

然后就是注意因为是对象，所以为null，在创建数据库实体的时候，和字段的对应关系需要想清楚处理。

### IO流

io流在开发中用得不多，出了For.steam()/pullsteam() ，这种并发流、流的形式去操作一个集合外，影响深的应该就是关于文件流的操作了。

比如copy文件，虽然可以用流的操作，通过读写copy，但是file的api里也自带了copy的方法。

但是文件流更多的用在传输上，将文件转换成流的形式，这样就可以远程上传文件FTP，或下载，或使用页面资源反馈等等。

### 序列化

一定一定要记得实现对象序列化，**并且**自定义一个版本号出来。

因为在使用缓存的项目中，或者写入队列缓存、本地文件时，都会注意到这个对象合不合法。


