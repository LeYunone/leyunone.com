---
date: 2021-09-09
title: LeetCode-283. 移动零
category: 刷题日记
tag:
  - LeetCode
head:
  - - meta
    - name: keywords
      content: LeetCode,算法,刷题日记
  - - meta
    - name: description
      content: 乐云一刷题日记！！！
---
**示例1：**
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
## 思路
题目比较简单，因为只能操作原数组，所以只可能是比较和交换的过程。不然还可以选择使用栈进行压底操作。
比较或交换局限性就小了，可以想到：
1. 所有0都要到队尾
2. 非零数不能乱序

那么，在比较和交换的算法里，可以想到快排的思路很适合这种“有序”数组。
**理由：** 快排，选中一个临界值，大于这个临界值的放在右边，小于的放在右边。
在看题目，可以将0当做临界值，等于0的放在右边，不等于0的放在左边。
那么思路就清晰了。
例：
1. 当前下标j=0 ->[j]=0 为临界值，与下标i=0 -> [i]=0 比较，发现等于0，那么不需要操作，因为[i]已经和[j]同位，可以当做已经在其右边
2. 当前下标j=0 ->[j]=0 为临界值，与下标i=1 -> [i]=1 比较，发现不等于0，将[i]放到[j]左边，所以将[i]和[j]的值进行交换，下标j(临街值)下标 = i ,因为是一次循环,所以j++;
3. 当前下标j=1 ->[j]=0 为临界值，与下标i=2 -> [i]=0 比较, ...........
4. ...

后续就是这样的思路进行操作，下面就是代码翻译工作了。

## 代码
```
public void moveZeroes(int[] nums) {
        if(nums.length==1){
            return ;
        }
       int j=0; //临界值0的下标
       for(int i=0;i<nums.length;i++){
           if(nums[i]!=0){
               //如果下标i的值不为零，则将其放到0的左边
               if(i>j){
                //当移动指针 快于 当前0指针时才需交换
                int temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
               }
               j++;
           }
       }
}
``` 
![QQ截图20210909103028.png](https://leyuna-blog-img.oss-cn-hangzhou.aliyuncs.com/image/2021-09-09/QQ截图20210909103028.png)
